/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ui;
import java.io.*;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.border.LineBorder;
import javax.swing.border.TitledBorder;

import solver.AStar;
import solver.Param;
import ui.ColorBridgeOfficial;
import solver.AStar;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger; 
/**
 *
 * @author hieutranbk
 */

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
public class ColorBridgeOfficial extends javax.swing.JFrame {

    public ColorBridgeOfficial() {
    	walkFiles();
        initComponents();
//        readFile();
        
        reset();
    }
    
    public ColorBridgeOfficial(int MAP_SIZE) {
        this.MAP_SIZE = MAP_SIZE;
        walkFiles();
        initComponents();
        reset();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">        
    
    private class MyMouseListener extends MouseAdapter {
        int i, j;
       
        public MyMouseListener(int i, int j){
            this.i = i;
            this.j = j;
        }
        @Override
        public void mouseClicked(MouseEvent e) {
//            setBiggerColor(i, j);
        	if(ColorBridgeOfficial.this.nowColor[i][j] != 0)
            	ColorBridgeOfficial.this.colorCount[ColorBridgeOfficial.this.nowColor[i][j]]--; 
        	ColorBridgeOfficial.this.nowColor[i][j] = ColorBridgeOfficial.this.selectedColor;
        	ColorBridgeOfficial.this.initialColor[i][j] = ColorBridgeOfficial.this.selectedColor;
        	ColorBridgeOfficial.this.colorCount[ColorBridgeOfficial.this.selectedColor]++; 
        	setColor(i, j, ColorBridgeOfficial.this.selectedColor);
        }
    }
    
    private class ColorMouseListener extends MouseAdapter {
    	int selectedColor;
    	
    	public ColorMouseListener(int selectedColor) {
    		this.selectedColor = selectedColor;
    	};
    	
    	public void mouseClicked(MouseEvent e) {
    		ColorBridgeOfficial.this.selectedColor = this.selectedColor;
    	}
    }
    
    private class MoveMouseListener extends MouseAdapter {
    	int i, j;
    	
    	public MoveMouseListener(int i, int j) {
    		this.i = i;
    		this.j = j;
    	}
    	
    	public void mouseClicked(MouseEvent e) {
    		int past_i = ColorBridgeOfficial.this.active_i;
    		int past_j = ColorBridgeOfficial.this.active_j;
    		if(past_i == this.i && past_j == this.j)
    			return;
    		int ok = ColorBridgeOfficial.this.isNeighbor(past_i, past_j, this.i, this.j);
    		if(ok == 1) {
    			if(past_i != 0 && past_j != 0)
        			ColorBridgeOfficial.this.jButton[past_i][past_j].setBorder(BorderFactory.createEmptyBorder());
	    		ColorBridgeOfficial.this.active_j = this.j;
	    		ColorBridgeOfficial.this.active_i = this.i;
	    		ColorBridgeOfficial.this.jButton[i][j].setBorder(BorderFactory.createLineBorder(Color.WHITE, 2));
    		}
    		if(ok == 2) {
    			if(past_i != 0 && past_j != 0)
        			ColorBridgeOfficial.this.jButton[past_i][past_j].setBorder(BorderFactory.createEmptyBorder());
    			int direction = 0;
    			if(this.i - past_i == -1)
    				direction = 1;
    			if(this.j - past_j == 1)
    				direction = 2;
    			if(this.i - past_i == 1)
    				direction = 3;
    			if(this.j - past_j == -1)
    				direction = 4;
    			ColorBridgeOfficial.this.flowCount[past_i][past_j] += 1;
    			ColorBridgeOfficial.this.flowCount[this.i][this.j] += 1;

    			if(initialColor[past_i][past_j]!=0) {
    				isActivated[initialColor[past_i][past_j]] = true;
    				isHead[past_i][past_j] = true;
    			}
    			
    			ColorBridgeOfficial.this.moveColor(ColorBridgeOfficial.this.nowColor[past_i][past_j], past_i, past_j, direction);
	    		ColorBridgeOfficial.this.active_j = this.j;
	    		ColorBridgeOfficial.this.active_i = this.i;
	    		ColorBridgeOfficial.this.jButton[i][j].setBorder(BorderFactory.createLineBorder(Color.WHITE, 2));
    		}
    	}
    }
    
    public int isNeighbor(int i, int j, int x, int y){
    	if(i == 0 && j==0) {
    		if(nowColor[x][y] !=0)
    			return 1;
    		return 0;
    	}
    	if(Math.abs(x-i) + Math.abs(y-j) == 1) {
    		if((nowColor[i][j] !=0 && nowColor[x][y] == 0) || nowColor[i][j] == nowColor[x][y]) {
    			if(flowCount[i][j] == 2 
    					|| flowCount[x][y] == 2 
    					|| (initialColor[i][j]!=0 && flowCount[i][j]==1) 
    					|| (initialColor[x][y]!=0 && flowCount[x][y]==1)
    					|| (isActivated[initialColor[i][j]] == true && initialColor[i][j]!=0))
    				return 0;
    			return 2;
    		}
    		else return 1;
    	}
    	else {
    		if(nowColor[x][y] == 0)
    			return 0;
    		else return 1;
    	}
    }
    
    private void readSolution(String fileName) {
    	String line = null;
    	try {
            // FileReader reads text files in the default encoding.
            FileReader fileReader = new FileReader(fileName);

            // Always wrap FileReader in BufferedReader.
            BufferedReader bufferedReader = 
                new BufferedReader(fileReader);
            line = bufferedReader.readLine();
            if (line.trim().equals("NoSolution"))
	            JOptionPane.showMessageDialog(rootPane, "NO SOLUTION", "", 1);
            else if (line.trim().equals("LimitExceed"))
	            JOptionPane.showMessageDialog(rootPane, "LIMIT EXCEED", "", 1);
            
            Timer timer = new Timer();
            puzzleSelectCb.setEnabled(false);
            resetBtn.setEnabled(false);
            backBtn.setEnabled(false);
            timer.schedule(new TimerTask() {
				@Override
				public void run() {
					String line = null;
					try {
						line = bufferedReader.readLine();
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					if (line == null) {
						try {
				            puzzleSelectCb.setEnabled(true);
				            resetBtn.setEnabled(true);
				            backBtn.setEnabled(true);
							bufferedReader.close();
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} 
						this.cancel();
						return;
					}
					String[] nums = line.split(" ");
	            	int x = Integer.parseInt(nums[0]) + 1;
	            	int y = Integer.parseInt(nums[1]) + 1;
	            	int direction = Integer.parseInt(nums[2]) + 1;
	            	int color = nowColor[x][y];
	            	moveColor(color, x, y, direction);
					
				}
			}, 0, 100);
//            while((line = bufferedReader.readLine()) != null) {
//            	String[] nums = line.split(" ");
//            	int x = Integer.parseInt(nums[0]) + 1;
//            	int y = Integer.parseInt(nums[1]) + 1;
//            	int direction = Integer.parseInt(nums[2]) + 1;
//            	int color = nowColor[x][y];
//            	moveColor(color, x, y, direction);
//
////				Thread.sleep(100);    
//            }
            
            // Always close files.
            //bufferedReader.close();         
        }
        catch(FileNotFoundException ex) {
            System.out.println(
                "Unable to open file '" + 
                fileName + "'");                
        }
        catch(IOException ex) {
            System.out.println(
                "Error reading file '" 
                + fileName + "'");                  
            // Or we could just do this: 
            // ex.printStackTrace();
        } 
//    	catch (InterruptedException e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
    }
      
    private void readFile(String filePath) {
    	String fileName = "puzzles/" + filePath + ".txt";
    	String line = null;
    	for(int i = 0; i<MAX_COLOR; ++i)
    		colorCount[i] = 0;
    	try {
            // FileReader reads text files in the default encoding.
            FileReader fileReader = new FileReader(fileName);

            // Always wrap FileReader in BufferedReader.
            BufferedReader bufferedReader = 
                new BufferedReader(fileReader);
            
            HashMap<String, Integer> map = new HashMap<>();
		   
            int count = 0;
            
            for(int i = 1; i<=MAP_SIZE; ++i) {
            	line = bufferedReader.readLine();
            	for(int j = 1; j<=MAP_SIZE; ++j) {
            		if(line.charAt(j-1) == '.')
            			nowColor[i][j] = 0;
            		else {
	            		if(map.containsKey(String.valueOf(line.charAt(j-1))))
	            			nowColor[i][j] = map.get(String.valueOf(line.charAt(j-1)));
	            		else {
	            			++count;
	            			map.put(String.valueOf(line.charAt(j-1)), count);
	            			nowColor[i][j] = count;
	            		}
            		}
            		initialColor[i][j] = nowColor[i][j]; 
        			setColor(i,j,nowColor[i][j]);
        			colorCount[nowColor[i][j]] += 1;
            	}
            }
            // Always close files.
            bufferedReader.close();         
        }
        catch(FileNotFoundException ex) {
            System.out.println(
                "Unable to open file '" + 
                fileName + "'");                
        }
        catch(IOException ex) {
            System.out.println(
                "Error reading file '" 
                + fileName + "'");                  
            // Or we could just do this: 
            // ex.printStackTrace();
        }
    }
    
    private int getSize(String fileName) {
    	String line = null;
    	try {
            // FileReader reads text files in the default encoding.
            FileReader fileReader = 
                new FileReader(fileName);

            // Always wrap FileReader in BufferedReader.
            BufferedReader bufferedReader = 
                new BufferedReader(fileReader);

            line = bufferedReader.readLine();
            bufferedReader.close();         
            return line.length();
        }
        catch(FileNotFoundException ex) {
            return 0; 
        }
        catch(IOException ex) {
            return 0;
        }	
    }
    
    private void walkFiles() {
        File folder = new File("puzzles");

        File[] listOfFiles = folder.listFiles();
        
        int fileCount = 0;
        for (int i = 0; i<listOfFiles.length; ++i) 
            if (listOfFiles[i].isFile() && getSize("puzzles/" + listOfFiles[i].getName()) == MAP_SIZE)
            	fileCount++;
        fileList = new String[fileCount+1];
        fileList[0] = "Puzzles from file";
        int j = 1;
        for (int i = 0; i<listOfFiles.length; ++i) 
            if (listOfFiles[i].isFile() && getSize("puzzles/" + listOfFiles[i].getName()) == MAP_SIZE) {
            	String fileName = listOfFiles[i].getName();
            	fileList[j++] = fileName.substring(0, fileName.length()-4);
            }
    }
        
    private void initComponents() {

        rootX[1] = ROOT_X; rootY[1] = ROOT_Y;
        for (int i = 2; i <= MAP_SIZE; i++) {
            rootX[i] = rootX[i-1] + BTN_SIZE;
            rootY[i] = rootY[i-1] + BTN_SIZE;
        }
        for (int i = 0; i < colorList.length; i++) {
            panelColor[i] = new javax.swing.JPanel();
        }
        for (int i = 1; i <= MAP_SIZE; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                jButton[i][j] = new javax.swing.JButton();
                jPanel[i][j][0] = new javax.swing.JPanel();
                if (i!=1) jPanel[i][j][1] = new javax.swing.JPanel();
                if (i!=MAP_SIZE) jPanel[i][j][3] = new javax.swing.JPanel();
                if (j!=1) jPanel[i][j][4] = new javax.swing.JPanel();
                if (j!=MAP_SIZE) jPanel[i][j][2] = new javax.swing.JPanel();
            }
        }
        resetBtn = new javax.swing.JButton();
        startBtn = new javax.swing.JButton();
        drawBtn = new javax.swing.JButton();
        backBtn = new javax.swing.JButton();
        puzzleSelectCb = new javax.swing.JComboBox<>();
        oneBtn = new javax.swing.JButton();
        
        
        setTitle("AI flow free");
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setPreferredSize(new java.awt.Dimension(200+BTN_SIZE*MAP_SIZE, 160 + BTN_SIZE*MAP_SIZE));
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());
        setResizable(false);
        setLocation(900 - 60*MAP_SIZE, 0);
        setAlwaysOnTop(true);
        
        for (int i = 0; i < colorList.length-1 ; i++) {
            panelColor[i].setVisible(true);
            panelColor[i].setToolTipText("" + i);
            panelColor[i].setBackground(colorList[i]);
            panelColor[i].setPreferredSize(new java.awt.Dimension(PNL_SIZE, PNL_SIZE));
            getContentPane().add(panelColor[i], new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 90 + (i-1)*(40+BTN_SIZE*MAP_SIZE)/(colorList.length-2), -1, -1));
            panelColor[i].addMouseListener(new ColorMouseListener(i));
        }
        
        for (int i = 1; i <= MAP_SIZE; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                jPanel[i][j][0].setBackground(Color.WHITE);
                jPanel[i][j][0].setPreferredSize(new java.awt.Dimension(PNL_SIZE, PNL_SIZE));
                getContentPane().add(jPanel[i][j][0], new org.netbeans.lib.awtextra.AbsoluteConstraints(100+(j-1)*BTN_SIZE, (i-1)*BTN_SIZE, -1, -1));
                if (i!=1) {
                    jPanel[i][j][1].setBackground(Color.WHITE);
                    jPanel[i][j][1].setPreferredSize(new java.awt.Dimension(PNL_SIZE, PNL_SIZE));
                    getContentPane().add(jPanel[i][j][1], new org.netbeans.lib.awtextra.AbsoluteConstraints(80+(j-1)*BTN_SIZE, 160+(i-2)*BTN_SIZE, -1, -1));
                }
                if (i!=MAP_SIZE) {
                    jPanel[i][j][3].setBackground(Color.WHITE);
                    jPanel[i][j][3].setPreferredSize(new java.awt.Dimension(PNL_SIZE, PNL_SIZE));
                    getContentPane().add(jPanel[i][j][3], new org.netbeans.lib.awtextra.AbsoluteConstraints(80+(j-1)*BTN_SIZE, 140+(i-1)*BTN_SIZE, -1, -1));
                }
                if (j!=1) {
                    jPanel[i][j][4].setBackground(Color.WHITE);
                    jPanel[i][j][4].setPreferredSize(new java.awt.Dimension(PNL_SIZE, PNL_SIZE));
                    getContentPane().add(jPanel[i][j][4], new org.netbeans.lib.awtextra.AbsoluteConstraints(120+(j-2)*BTN_SIZE, 120+(i-1)*BTN_SIZE, -1, -1));
                }
                if (j!=MAP_SIZE) {
                    jPanel[i][j][2].setBackground(Color.WHITE);
                    jPanel[i][j][2].setPreferredSize(new java.awt.Dimension(PNL_SIZE, PNL_SIZE));
                    getContentPane().add(jPanel[i][j][2], new org.netbeans.lib.awtextra.AbsoluteConstraints(100+(j-1)*BTN_SIZE, 120+(i-1)*BTN_SIZE, -1, -1));
                }
            }
        }

        for (int i = 1; i <= MAP_SIZE; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                jButton[i][j].setBackground(new java.awt.Color(255, 255, 255));
                jButton[i][j].setPreferredSize(new java.awt.Dimension(60, 60));
//                jButton[i][j].setBorderPainted();
                jButton[i][j].setMargin(new java.awt.Insets(0, 0, 0, 0));
                getContentPane().add(jButton[i][j], new org.netbeans.lib.awtextra.AbsoluteConstraints(60+(j-1)*BTN_SIZE, 100+(i-1)*BTN_SIZE, -1, -1));
            }
        }

        resetBtn.setBackground(new java.awt.Color(255, 255, 255));
        resetBtn.setFont(font); // NOI18N
        resetBtn.setText("RESET");
        resetBtn.setPreferredSize(new java.awt.Dimension(60, 60));
        resetBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetBtnActionPerformed(evt);
            }
        });
        getContentPane().add(resetBtn, new org.netbeans.lib.awtextra.AbsoluteConstraints(MAP_SIZE*BTN_SIZE*3/4, 15, 70, 35));

        startBtn.setBackground(new java.awt.Color(255, 255, 255));
        startBtn.setFont(font); // NOI18N
        startBtn.setText("START");
        startBtn.setPreferredSize(new java.awt.Dimension(60, 60));
        startBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startBtnActionPerformed(evt);
            }
        });
        getContentPane().add(startBtn, new org.netbeans.lib.awtextra.AbsoluteConstraints(MAP_SIZE*BTN_SIZE*1/4, 15, 70, 35));
        
        drawBtn.setBackground(new java.awt.Color(255, 255, 255));
        drawBtn.setFont(font); // NOI18N
        drawBtn.setText("DRAW");
        drawBtn.setPreferredSize(new java.awt.Dimension(60, 60));
        drawBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                drawBtnPerformed(evt);
            }
        });
        getContentPane().add(drawBtn, new org.netbeans.lib.awtextra.AbsoluteConstraints(MAP_SIZE*BTN_SIZE*2/4, 15, 70, 35));

        backBtn.setBackground(new java.awt.Color(255, 255, 255));
        backBtn.setFont(font); // NOI18N
        backBtn.setText("<");
        backBtn.setPreferredSize(new java.awt.Dimension(60, 60));
        backBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StartMenu.main(new String[]{});
                setVisible(false);
            }
        });
        getContentPane().add(backBtn, new org.netbeans.lib.awtextra.AbsoluteConstraints(5, 15, 40, 35));

        
        puzzleSelectCb.setFont(font); // NOI18N
        puzzleSelectCb.setModel(new javax.swing.DefaultComboBoxModel<>(fileList));
        
        puzzleSelectCb.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				reset();
				readFile(puzzleSelectCb.getSelectedItem().toString());
			}
		});
        
        getContentPane().add(puzzleSelectCb, new org.netbeans.lib.awtextra.AbsoluteConstraints(MAP_SIZE*BTN_SIZE/2 - 40, 60, 160, 30));
        
        oneBtn.setText("+");
        oneBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                oneBtnActionPerformed(evt);
            }
        });
        getContentPane().add(oneBtn, new org.netbeans.lib.awtextra.AbsoluteConstraints(MAP_SIZE*BTN_SIZE/2 - 85, 55, 40, 40));
        
//        private javax.swing.JCheckBox selfTouchable;
//        private javax.swing.JCheckBox forceMove;
//        private javax.swing.JCheckBox activeColor;
//        private javax.swing.JCheckBox outIn;
//        private javax.swing.JCheckBox diagnose;
//        private javax.swing.JCheckBox g;
        selfTouchable = new javax.swing.JCheckBox("selfTouchable");
        forceMove = new javax.swing.JCheckBox("forceMove");
        activeColor = new javax.swing.JCheckBox("activeColor");
        outIn = new javax.swing.JCheckBox("outIn");
        diagnose = new javax.swing.JCheckBox("diagnose");
        g = new javax.swing.JCheckBox("g");

        SpinnerModel value = new SpinnerNumberModel(0.5, 0.05, 0.95, 0.05);
        spinner = new JSpinner(value);
        
        configPanel = new javax.swing.JPanel();
        TitledBorder title;
        
        hFunctionCb = new javax.swing.JComboBox<>();
        sortColorCb = new javax.swing.JComboBox<>();
        
        selfTouchable.setFont(font);
        forceMove.setFont(font);
        activeColor.setFont(font);
        outIn.setFont(font);
        diagnose.setFont(font);
        g.setFont(font);
        
        selfTouchable.setSelected(false);
        forceMove.setSelected(true);
        activeColor.setSelected(true);
        outIn.setSelected(true);
        diagnose.setSelected(true);
        g.setSelected(true);
        
        activeColor.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		sortColorCb.setEnabled(activeColor.isSelected());
        	}
        });
        
        g.addActionListener(new ActionListener() {
        	public void actionPerformed(ActionEvent e) {
        		spinner.setEnabled(g.isSelected());
        	}
        });
        
        hFunctionCb.setFont(font); // NOI18N
        hFunctionCb.setModel(new javax.swing.DefaultComboBoxModel<>(hFunction));
        
        hFunctionCb.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				System.out.println(hFunctionCb.getSelectedIndex());
			}
		});
        
        sortColorCb.setFont(font); // NOI18N
        sortColorCb.setModel(new javax.swing.DefaultComboBoxModel<>(sortColor));
        
        sortColorCb.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				System.out.println(sortColorCb.getSelectedIndex());
			}
		});
        
        title = BorderFactory.createTitledBorder(
        		BorderFactory.createLineBorder(Color.DARK_GRAY, 1), "Config");
        title.setTitleFont(font);
		title.setTitleJustification(TitledBorder.DEFAULT_POSITION);
		configPanel.setBorder(title);
		configPanel.setBackground(new Color(0,0,0));
		configPanel.setOpaque(false);
//		200+BTN_SIZE*MAP_SIZE, 160 + BTN_SIZE*MAP_SIZE
        getContentPane().add(configPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(70 + MAP_SIZE*BTN_SIZE, 15, 120, 100 + BTN_SIZE*MAP_SIZE));
        getContentPane().add(selfTouchable, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*2/24, -1, -1));
        getContentPane().add(forceMove, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*4/24, -1, -1));
        getContentPane().add(activeColor, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*6/24, -1, -1));
        getContentPane().add(outIn, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*8/24, -1, -1));
        getContentPane().add(diagnose, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*10/24, -1, -1));
        getContentPane().add(g, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*12/24, -1, -1));
        
        getContentPane().add(hFunctionCb, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*14/24, 110, 30));
        getContentPane().add(sortColorCb, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*16/24, 110, 30));
        
        JLabel jLabel = new JLabel("G rate:");
        jLabel.setFont(font);
        getContentPane().add(jLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*18/24, 110, 30));
        getContentPane().add(spinner, new org.netbeans.lib.awtextra.AbsoluteConstraints(75 + MAP_SIZE*BTN_SIZE, (160 + BTN_SIZE*MAP_SIZE)*19/24, 110, 30));

        pack();
    }// </editor-fold>                                                    
    
    private void setBiggerColor(int x, int y){
        setLayout(null);
        nowColor[x][y] = (nowColor[x][y]+1) % colorList.length;
        jPanel[x][y][0].setBackground(colorList[nowColor[x][y]]);
        if (nowColor[x][y] == 0){
            jPanel[x][y][0].setVisible(false);
            jPanel[x][y][0].setBounds(rootX[y], rootY[x], PNL_SIZE, PNL_SIZE);
            jButton[x][y].setBackground(Color.WHITE);
            jButton[x][y].setText("");
        } else if (nowColor[x][y] == colorList.length-1){
            colorCount[colorList.length-2]--;
            jPanel[x][y][0].setVisible(false);
            jButton[x][y].setBackground(Color.DARK_GRAY);
            jButton[x][y].setFont(new java.awt.Font("Tahoma", 1, 36));
            jButton[x][y].setText("X");
        } else {
            colorCount[nowColor[x][y]]++;
            if (nowColor[x][y] !=1) colorCount[nowColor[x][y]-1]--;
            jPanel[x][y][0].setVisible(true);
            jPanel[x][y][0].setBounds(rootX[y]-DELTA, rootY[x]-DELTA, PNL_SIZE+2*DELTA, PNL_SIZE+2*DELTA);
        }
    }      
    
    private void setColor(int x, int y, int color) {
    	setLayout(null);
        jPanel[x][y][0].setBackground(colorList[color]);
        if (color == 0){
            jPanel[x][y][0].setVisible(false);
            jPanel[x][y][0].setBounds(rootX[y], rootY[x], PNL_SIZE, PNL_SIZE);
            jButton[x][y].setBackground(Color.WHITE);
            jButton[x][y].setText("");
        } else {
            jPanel[x][y][0].setVisible(true);
            jPanel[x][y][0].setBounds(rootX[y]-DELTA, rootY[x]-DELTA, PNL_SIZE+2*DELTA, PNL_SIZE+2*DELTA);
        }
    }
    
    private void moveColor(int numColor, int x, int y, int direction) {
    	PrintWriter writer;
		try {
//			writer = new PrintWriter("Move.txt", "UTF-8");
		    writer = new PrintWriter(new BufferedWriter(new FileWriter("Move.txt", true)));
			String line = Integer.toString(x-1) + " " + Integer.toString(y-1) + " " + Integer.toString(direction-1);
			writer.println(line);
	        writer.close();

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
    	Color color = colorList[numColor];
    	
    	jButton[x][y].setBackground(color.brighter().darker());
    	jPanel[x][y][direction].setVisible(true);
    	jPanel[x][y][direction].setBackground(color);
    	
    	switch(direction) {
    		case 1: x = x-1;
    				break;
    		case 2: y = y+1;
    				break;
    		case 3: x = x+1;
    				break;
    		case 4: y = y-1;
    				break;
    		default: break;
    	}
    	
    	if(direction-2 > 0)
    		direction-=2;
    	else direction += 2;
    	
    	jButton[x][y].setBackground(color.brighter().darker());
        
        jPanel[x][y][0].setBackground(color);
        jPanel[x][y][0].setVisible(true);
        jPanel[x][y][direction].setBackground(color);
        jPanel[x][y][direction].setVisible(true);
        nowColor[x][y] = numColor;
    }

    private void matchColor(Color color, ArrayList<Integer> arrX, ArrayList<Integer> arrY){
        setLayout(null);
        int x = arrX.get(0), y = arrY.get(0), n = arrX.size();

        for (int i = 0; i < n; i++) {
            x = arrX.get(i); y = arrY.get(i);
            
            jButton[x][y].setBackground(color.brighter().darker());
            
            jPanel[x][y][0].setBackground(color);
            jPanel[x][y][0].setVisible(true);
            
            if (i>0){
                if (x == arrX.get(i-1)){
                    if (y < arrY.get(i-1)){
                        jPanel[x][y][2].setVisible(true);
                        jPanel[x][y][2].setBackground(color);
                    } else {
                        jPanel[x][y][4].setVisible(true);
                        jPanel[x][y][4].setBackground(color);
                    }
                } else {
                    if (x < arrX.get(i-1)){
                        jPanel[x][y][3].setVisible(true);
                        jPanel[x][y][3].setBackground(color);
                    } else {
                        jPanel[x][y][1].setVisible(true);
                        jPanel[x][y][1].setBackground(color);
                    }
                }
            }
            if (i<n-1){
                if (x == arrX.get(i+1)){
                    if (y < arrY.get(i+1)){
                        jPanel[x][y][2].setVisible(true);
                        jPanel[x][y][2].setBackground(color);
                    } else {
                        jPanel[x][y][4].setVisible(true);
                        jPanel[x][y][4].setBackground(color);
                    }
                } else {
                    if (x < arrX.get(i+1)){
                        jPanel[x][y][3].setVisible(true);
                        jPanel[x][y][3].setBackground(color);
                    } else {
                        jPanel[x][y][1].setVisible(true);
                        jPanel[x][y][1].setBackground(color);
                    }
                }
            }
        }
        
    }
    
    private void resetBtnActionPerformed(java.awt.event.ActionEvent evt) {    
        reset();
    }              

    private void drawBtnPerformed(java.awt.event.ActionEvent evt) {
        drawBtn.setEnabled(false);

    	int cheDo = 0;
        boolean ok = false;
        for (int i = 1; i < colorList.length-1; i++) {
            if (colorCount[i]!=2 && colorCount[i]!=0){
                String errorMessage = "Fill exactly 2 Cells for each Color";
                JOptionPane.showMessageDialog(rootPane, errorMessage, "WARNING", 2);
                return;
            }
            if (colorCount[i] > 0) ok=true;
        }
        if (ok == false){
            String errorMessage = "Fill at least 1 Color";
            JOptionPane.showMessageDialog(rootPane, errorMessage, "WARNING", 2);
            return;
        }
        
        for (int i = 1; i <= MAP_SIZE; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                for( MouseListener al : jButton[i][j].getMouseListeners() ) {
                    jButton[i][j].removeMouseListener(al);
                } 
                jButton[i][j].addMouseListener(new MoveMouseListener(i,j));
            }
        }
    }
    
    private void setParam() {
    	Param.selfTouchable = selfTouchable.isSelected();
    	Param.forcedMove = forceMove.isSelected();
    	Param.activeColor = activeColor.isSelected();
    	Param.out_in = outIn.isSelected();
    	Param.diagnose = diagnose.isSelected();
    	Param.g = g.isSelected();
    	
    	Param.h = selectedH;
    	
    	if(activeColor.isSelected())
    		Param.sortColor = selectedSortColor;
    }
    
    private void startBtnActionPerformed(java.awt.event.ActionEvent evt) {
    	setParam();
    	startBtn.setEnabled(false);
        drawBtn.setEnabled(false);
        int cheDo = 0;
        boolean ok = false;
        for (int i = 1; i < colorList.length-1; i++) {
            if (colorCount[i]!=2 && colorCount[i]!=0){
                String errorMessage = "Fill exactly 2 Cells for each Color";
                JOptionPane.showMessageDialog(rootPane, errorMessage, "WARNING", 2);
                return;
            }
            if (colorCount[i] > 0) ok=true;
        }
        if (ok == false){
            String errorMessage = "Fill at least 1 Color";
            JOptionPane.showMessageDialog(rootPane, errorMessage, "WARNING", 2);
            return;
        }
        
        for (int i = 1; i <= MAP_SIZE; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                for( MouseListener al : jButton[i][j].getMouseListeners() ) {
                    jButton[i][j].removeMouseListener(al);
                } 
            }
        }
        
        PrintWriter writer;
		try {
			writer = new PrintWriter("Puzzle.txt", "UTF-8");
			for (int i=1; i<=MAP_SIZE; ++i) {
	        	for(int j=1; j<=MAP_SIZE; ++j) {
	        		if(initialColor[i][j] == 0) 
	        			writer.print(".");
	        		else {
	        			if(isActivated[initialColor[i][j]]) {
		        			if(isHead[i][j])
		        				writer.print((char)(initialColor[i][j]+64));
		        			else
		        				writer.print((char)(initialColor[i][j]+96));
	        			}
	        			else {
	        				isHead[i][j] = true;
	        				isActivated[initialColor[i][j]] = true;
	        				writer.print((char)(initialColor[i][j]+64));
	        			}
	        		}
	        	}
	        	writer.println("");
	        }
	        writer.close();

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        
        int [][] table = new int[MAP_SIZE+3][MAP_SIZE+3];
        int numFlow = 0;
        for (int i = 1; i < colorList.length-1; i++) {
            if (colorCount[i] == 2) numFlow++;
        }
        
        for (int i = 1; i <= MAP_SIZE; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                if (nowColor[i][j] == colorList.length-1){
                    table[i][j] = -1;
                } else if (nowColor[i][j] != 0){
                    table[i][j] = nowColor[i][j];
                }
            }
        }
        
        try {
			AStar sol = new AStar(new File("Puzzle.txt"));
			sol.solve(new AtomicInteger());
			readSolution("Solution.txt");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }       

    private void oneBtnActionPerformed(java.awt.event.ActionEvent evt) {    
        if (flowNow == numNow) oneBtn.setVisible(false);
        ArrayList<Integer> arX = new ArrayList<Integer>();
        ArrayList<Integer> arY = new ArrayList<Integer>();
        arX = flowsNow.get((flowNow-1)*2);
        arY = flowsNow.get((flowNow-1)*2+1);
        Color col = colorList[tableNow[(int)arX.get(0)][(int)arY.get(0)]];
        matchColor(col, arX, arY);
        flowNow++;
    }  
    
    private void reset(){
    	PrintWriter writer;
		try {
			writer = new PrintWriter("Move.txt");
			writer.print("");
	    	writer.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	
    	selectedH = 0;
    	selectedSortColor = 0;
        for (int i = 1; i <= MAP_SIZE; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                for( MouseListener al : jButton[i][j].getMouseListeners() ) {
                    jButton[i][j].removeMouseListener(al );
                    jButton[i][j].setBorderPainted(true);
                	jButton[i][j].setBorder(BorderFactory.createEmptyBorder());
                } 
            }
        }
        for (int i = 0; i < MAX_COLOR-1; i++) {
            colorCount[i]=0;
            isActivated[i]=false;
        }
        
        for (int i = 1; i <= MAP_SIZE ; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                nowColor[i][j] = 0;
                flowCount[i][j] = 0;
                initialColor[i][j] = 0;
                isHead[i][j] = false;
                jPanel[i][j][0].setVisible(false);
                jButton[i][j].setBackground(new Color(255, 255, 255));
                jButton[i][j].setText("");
                jPanel[i][j][0].setBounds(rootX[j], rootY[i], PNL_SIZE, PNL_SIZE);
                if (i != 1) {
                    jPanel[i][j][1].setVisible(false);
                }
                if (i != MAP_SIZE) {
                    jPanel[i][j][3].setVisible(false);
                }
                if (j != 1) {
                    jPanel[i][j][4].setVisible(false);
                }
                if (j != MAP_SIZE) {
                    jPanel[i][j][2].setVisible(false);
                }
            }
        }
        
        for (int i = 1; i <= MAP_SIZE ; i++) {
            for (int j = 1; j <= MAP_SIZE; j++) {
                jButton[i][j].addMouseListener(new MyMouseListener(i, j));
            }
        }
        oneBtn.setVisible(false);
        startBtn.setEnabled(true);
        drawBtn.setEnabled(true);
//        jButton[active_i][active_j].setBorder(BorderFactory.createEmptyBorder());
		active_i = 0;
		active_j = 0;
    }

    public void run() {
        setVisible(true);
    }
    
    private int active_i = 0;
    private int active_j = 0;
    private int selectedColor = 0;
    public int MAP_SIZE = 5;
    public final int MAX_MAP_SIZE = 14;
    public final int PNL_SIZE = 20;            
    public final int BTN_SIZE = 60;
    public final int ROOT_X = 80;
    public String[] fileList;
    public final int ROOT_Y = 120;
    public final int DELTA = 7;    
    public final int MAX_COLOR = 24;
    private final JPanel [][][] jPanel = new JPanel[MAX_MAP_SIZE+1][MAX_MAP_SIZE+1][MAX_MAP_SIZE];
    private final JButton [][] jButton = new JButton[MAX_MAP_SIZE+1][MAX_MAP_SIZE+1];
    private final JPanel[] panelColor = new JPanel[MAX_COLOR];
    private int [] rootX = new int[MAX_MAP_SIZE+1]; 
    private int [] rootY = new int[MAX_MAP_SIZE+1]; 
    public boolean[] isActivated = new boolean[MAX_COLOR];
    public int [][] flowCount = new int[MAX_MAP_SIZE+1][MAX_MAP_SIZE+1];
    public int [][] nowColor = new int[MAX_MAP_SIZE+1][MAX_MAP_SIZE+1];
    public int [][] initialColor = new int[MAX_MAP_SIZE+1][MAX_MAP_SIZE+1];
    public boolean [][] isHead = new boolean[MAX_MAP_SIZE+1][MAX_MAP_SIZE+1];
    private int [] colorCount = new int[MAX_COLOR];
    private final Color [] colorList = {Color.WHITE, 
    									Color.RED, 
    									Color.BLUE, 
    									Color.YELLOW, 
    									Color.GREEN, 
                                        Color.CYAN, 
                                        Color.MAGENTA, 
    									new Color(101,25,13), 
    									new Color(23, 102, 55), 
    									new Color(153, 0, 153),
                                        new Color(0, 153, 51), 
                                        new Color(102, 51, 200), 
                                        new Color(255, 153, 0), 
                                        new Color(51, 151, 205),
                                        new Color(131, 151, 101),
                                        new Color(200, 11, 145),
                                        new Color(11, 23, 145),
                                        Color.BLACK};
    int flowNow;
    ArrayList< ArrayList<Integer>> flowsNow = new ArrayList<>();
    int [][] tableNow = new int[MAP_SIZE+3][MAP_SIZE+3];
    int numNow;
    private javax.swing.JComboBox<String> puzzleSelectCb;
    private javax.swing.JButton oneBtn;
    private javax.swing.JButton resetBtn;
    private javax.swing.JButton startBtn;
    private javax.swing.JButton drawBtn;
    private javax.swing.JButton backBtn;
    private javax.swing.JCheckBox selfTouchable;
    private javax.swing.JCheckBox forceMove;
    private javax.swing.JCheckBox activeColor;
    private javax.swing.JCheckBox outIn;
    private javax.swing.JCheckBox diagnose;
    private javax.swing.JCheckBox g;
    
    private javax.swing.JComboBox<String> hFunctionCb;
    private javax.swing.JComboBox<String> sortColorCb;

    private final String[] hFunction = {"h0: free", "h1: wall", "h2: manhattan", "h3: free+wall", "h4: all combined"};
    private int selectedH = 0;
    
    private final String[] sortColor = {"0: not sort", "1: by moves", "2: by wall"};
    private int selectedSortColor = 0;
    private JSpinner spinner;
    
    private javax.swing.JPanel configPanel;
    private java.awt.Font font = new java.awt.Font("Tahoma", 0, 14);
    // End of variables declaration                   
}
